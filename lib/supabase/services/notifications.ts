import { createServiceClient } from '../server'

export interface Notification {
  id: string
  user_id: string
  type: 'reminder' | 'announcement' | 'schedule_change' | 'payment' | 'makeup'
  title: string
  body: string
  image_url: string | null
  action_url: string | null
  data: Record<string, unknown> | null
  is_read: boolean
  sent_at: string
  read_at: string | null
}

export interface NotificationMapped {
  id: string
  userId: string
  type: 'reminder' | 'announcement' | 'schedule_change' | 'payment' | 'makeup'
  title: string
  body: string
  imageUrl?: string
  actionUrl?: string
  data?: Record<string, unknown>
  isRead: boolean
  sentAt: Date
  readAt?: Date
}

function mapNotification(data: Notification): NotificationMapped {
  return {
    id: data.id,
    userId: data.user_id,
    type: data.type,
    title: data.title,
    body: data.body,
    imageUrl: data.image_url || undefined,
    actionUrl: data.action_url || undefined,
    data: data.data || undefined,
    isRead: data.is_read,
    sentAt: new Date(data.sent_at),
    readAt: data.read_at ? new Date(data.read_at) : undefined,
  }
}

// Create in-app notification
export async function createNotification(data: {
  userId: string
  type: 'reminder' | 'announcement' | 'schedule_change' | 'payment' | 'makeup'
  title: string
  body: string
  imageUrl?: string
  actionUrl?: string
  data?: Record<string, unknown>
}): Promise<string> {
  const supabase = createServiceClient()

  const { data: result, error } = await supabase
    .from('notifications')
    .insert({
      user_id: data.userId,
      type: data.type,
      title: data.title,
      body: data.body,
      image_url: data.imageUrl || null,
      action_url: data.actionUrl || null,
      data: data.data || null,
      is_read: false,
    })
    .select('id')
    .single()

  if (error) {
    console.error('Error creating notification:', error)
    throw error
  }

  return result.id
}

// Notify admin about new auto-generated makeup
export async function notifyAdminNewMakeup(
  studentName: string,
  className: string,
  missedSessions: number,
  branchId?: string
): Promise<void> {
  try {
    if (branchId) {
      await notifyAdminsInBranch(branchId, {
        type: 'makeup',
        title: 'มี Makeup Class อัตโนมัติใหม่',
        body: `นักเรียน ${studentName} ในคลาส ${className} มีการขาดเรียน ${missedSessions} ครั้ง (สร้างอัตโนมัติจากการสมัครหลังคลาสเริ่ม)`,
        actionUrl: '/makeup',
        data: {
          studentName,
          className,
          missedSessions,
          autoGenerated: true,
          branchId,
        },
      })
    } else {
      await createNotification({
        userId: 'admin',
        type: 'makeup',
        title: 'มี Makeup Class อัตโนมัติใหม่',
        body: `นักเรียน ${studentName} ในคลาส ${className} มีการขาดเรียน ${missedSessions} ครั้ง (สร้างอัตโนมัติจากการสมัครหลังคลาสเริ่ม)`,
        actionUrl: '/makeup',
        data: {
          studentName,
          className,
          missedSessions,
          autoGenerated: true,
        },
      })
    }

    console.log(`[Notification] Created auto-generated makeup notification for ${studentName}`)
  } catch (error) {
    console.error('Error sending notification:', error)
  }
}

// Notify admins in a specific branch
export async function notifyAdminsInBranch(
  branchId: string,
  notification: {
    type: 'reminder' | 'announcement' | 'schedule_change' | 'payment' | 'makeup'
    title: string
    body: string
    imageUrl?: string
    actionUrl?: string
    data?: Record<string, unknown>
  }
): Promise<void> {
  const supabase = createServiceClient()

  try {
    // Get all admins for this branch
    const { data: admins, error } = await supabase
      .from('admin_users')
      .select('id')
      .eq('is_active', true)
      .or(`branch_ids.cs.{${branchId}},role.eq.super_admin`)

    if (error) {
      console.error('Error getting admins:', error)
      return
    }

    // Create notification for each admin
    const promises = (admins || []).map((admin) =>
      createNotification({
        userId: admin.id,
        ...notification,
      })
    )

    await Promise.all(promises)

    console.log(`[Notification] Sent to ${admins?.length || 0} admins in branch ${branchId}`)
  } catch (error) {
    console.error('Error sending branch notifications:', error)
  }
}

// Get unread notifications for a user
export async function getUnreadNotifications(userId: string): Promise<NotificationMapped[]> {
  const supabase = createServiceClient()

  const { data, error } = await supabase
    .from('notifications')
    .select('*')
    .eq('user_id', userId)
    .eq('is_read', false)
    .order('sent_at', { ascending: false })

  if (error) {
    console.error('Error getting unread notifications:', error)
    return []
  }

  return (data || []).map(mapNotification)
}

// Get all notifications for a user
export async function getNotifications(
  userId: string,
  limit?: number
): Promise<NotificationMapped[]> {
  const supabase = createServiceClient()

  let query = supabase
    .from('notifications')
    .select('*')
    .eq('user_id', userId)
    .order('sent_at', { ascending: false })

  if (limit) {
    query = query.limit(limit)
  }

  const { data, error } = await query

  if (error) {
    console.error('Error getting notifications:', error)
    return []
  }

  return (data || []).map(mapNotification)
}

// Mark notification as read
export async function markNotificationAsRead(
  userId: string,
  notificationId: string
): Promise<void> {
  const supabase = createServiceClient()

  const { error } = await supabase
    .from('notifications')
    .update({
      is_read: true,
      read_at: new Date().toISOString(),
    })
    .eq('id', notificationId)
    .eq('user_id', userId)

  if (error) {
    console.error('Error marking notification as read:', error)
  }
}

// Mark all notifications as read
export async function markAllNotificationsAsRead(userId: string): Promise<void> {
  const supabase = createServiceClient()

  const { error } = await supabase
    .from('notifications')
    .update({
      is_read: true,
      read_at: new Date().toISOString(),
    })
    .eq('user_id', userId)
    .eq('is_read', false)

  if (error) {
    console.error('Error marking all notifications as read:', error)
  }
}

// Delete old notifications (cleanup)
export async function deleteOldNotifications(daysOld: number = 30): Promise<number> {
  const supabase = createServiceClient()

  const cutoffDate = new Date()
  cutoffDate.setDate(cutoffDate.getDate() - daysOld)

  const { data, error } = await supabase
    .from('notifications')
    .delete()
    .lt('sent_at', cutoffDate.toISOString())
    .select('id')

  if (error) {
    console.error('Error deleting old notifications:', error)
    return 0
  }

  return data?.length || 0
}
